<!-- Embeddable Space Shooter Game -->
<div id="gameContainer" class="game-container">
    <!-- Mini Game Widget -->
    <div id="gameMini" class="game-mini">
        <div class="game-mini-content">
            <div class="game-mini-icon">ðŸš€</div>
            <div class="game-mini-text">Play Game</div>
        </div>
    </div>

    <!-- Fullscreen Game -->
    <div id="gameFullscreen" class="game-fullscreen">
        <div class="game-header">
            <h2>Space Defender</h2>
            <div class="game-controls">
                <span id="score">Score: 0</span>
                <span id="lives">Lives: 3</span>
                <button id="closeGame" class="close-btn">Ã—</button>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="game-instructions">
            <p><strong>Controls:</strong> Arrow Keys to move â€¢ Spacebar to shoot â€¢ ESC to close</p>
        </div>
    </div>
</div>

<style>
.game-container {
    position: fixed;
    z-index: 1000;
}

/* Mini Game Widget */
.game-mini {
    position: fixed;
    left: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    animation: pulse 2s infinite;
}

.game-mini:hover {
    transform: translateY(-50%) scale(1.1);
    box-shadow: 0 6px 25px rgba(0,0,0,0.4);
}

.game-mini-content {
    text-align: center;
    color: white;
}

.game-mini-icon {
    font-size: 24px;
    margin-bottom: 2px;
}

.game-mini-text {
    font-size: 10px;
    font-weight: bold;
}

@keyframes pulse {
    0% { box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
    50% { box-shadow: 0 4px 30px rgba(102, 126, 234, 0.5); }
    100% { box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
}

/* Fullscreen Game */
.game-fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

.game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 800px;
    color: white;
    margin-bottom: 20px;
    padding: 0 20px;
}

.game-header h2 {
    margin: 0;
    font-size: 28px;
    text-shadow: 0 0 10px #00ff88;
}

.game-controls {
    display: flex;
    gap: 20px;
    align-items: center;
}

.game-controls span {
    font-size: 18px;
    font-weight: bold;
}

.close-btn {
    background: #ff4757;
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.close-btn:hover {
    background: #ff3742;
    transform: scale(1.1);
}

#gameCanvas {
    border: 2px solid #00ff88;
    background: linear-gradient(180deg, #000011 0%, #000033 100%);
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
}

.game-instructions {
    color: white;
    text-align: center;
    margin-top: 15px;
    opacity: 0.8;
}

/* Responsive Design */
@media (max-width: 850px) {
    #gameCanvas {
        width: 90vw;
        height: 60vh;
    }
    
    .game-header {
        width: 90vw;
    }
}
</style>

<script>
class SpaceShooterGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.score = 0;
        this.lives = 3;
        this.gameRunning = false;
        this.keys = {};
        
        // Game entities
        this.player = {
            x: this.canvas.width / 2 - 25,
            y: this.canvas.height - 60,
            width: 50,
            height: 40,
            speed: 5
        };
        
        this.bullets = [];
        this.enemies = [];
        this.particles = [];
        this.powerUps = [];
        this.enemyLanes = []; // Clear occupied lanes
        
        this.enemySpawnTimer = 0;
        this.powerUpSpawnTimer = 0;
        this.enemyLanes = []; // Track occupied lanes to prevent overlap
        
        this.initEventListeners();
    }
    
    initEventListeners() {
        // Keyboard events
        document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.gameRunning) {
                e.preventDefault();
                this.shootBullet();
            }
            if (e.code === 'Escape') {
                this.closeGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });
        
        // Game UI events
        document.getElementById('gameMini').addEventListener('click', () => {
            this.openGame();
        });
        
        document.getElementById('closeGame').addEventListener('click', () => {
            this.closeGame();
        });
    }
    
    openGame() {
        document.getElementById('gameMini').style.display = 'none';
        document.getElementById('gameFullscreen').style.display = 'flex';
        this.startGame();
    }
    
    closeGame() {
        document.getElementById('gameFullscreen').style.display = 'none';
        document.getElementById('gameMini').style.display = 'flex';
        this.gameRunning = false;
    }
    
    startGame() {
        this.gameRunning = true;
        this.score = 0;
        this.lives = 3;
        this.bullets = [];
        this.enemies = [];
        this.particles = [];
        this.powerUps = [];
        this.player.x = this.canvas.width / 2 - 25;
        this.updateUI();
        this.gameLoop();
    }
    
    gameLoop() {
        if (!this.gameRunning) return;
        
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
    
    update() {
        // Player movement
        if (this.keys['ArrowLeft'] && this.player.x > 0) {
            this.player.x -= this.player.speed;
        }
        if (this.keys['ArrowRight'] && this.player.x < this.canvas.width - this.player.width) {
            this.player.x += this.player.speed;
        }
        if (this.keys['ArrowUp'] && this.player.y > 0) {
            this.player.y -= this.player.speed;
        }
        if (this.keys['ArrowDown'] && this.player.y < this.canvas.height - this.player.height) {
            this.player.y += this.player.speed;
        }
        
        // Update bullets
        this.bullets.forEach((bullet, index) => {
            bullet.y -= bullet.speed;
            if (bullet.y < 0) {
                this.bullets.splice(index, 1);
            }
        });
        
        // Spawn enemies (slower spawn rate)
        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > 90) { // Increased from 60 to 90 for slower spawning
            this.spawnEnemy();
            this.enemySpawnTimer = 0;
        }
        
        // Update enemies
        this.enemies.forEach((enemy, index) => {
            enemy.y += enemy.speed;
            
            // Initialize horizontal velocity if not exists
            if (enemy.vx === undefined) {
                enemy.vx = (Math.random() - 0.5) * 2; // Random horizontal velocity
            }
            
            // Update horizontal position
            enemy.x += enemy.vx;
            
            // Check horizontal boundaries and bounce
            if (enemy.x <= 0) {
                enemy.x = 0;
                enemy.vx = -enemy.vx * 0.8; // Reverse direction and reduce speed by 20%
                enemy.speed *= 0.9; // Also reduce falling speed slightly
            } else if (enemy.x >= this.canvas.width - enemy.width) {
                enemy.x = this.canvas.width - enemy.width;
                enemy.vx = -enemy.vx * 0.8; // Reverse direction and reduce speed by 20%
                enemy.speed *= 0.9; // Also reduce falling speed slightly
            }
            
            if (enemy.y > this.canvas.height) {
                this.enemies.splice(index, 1);
                // Remove lane occupation when enemy leaves screen
                const laneIndex = this.enemyLanes.indexOf(enemy.lane);
                if (laneIndex > -1) {
                    this.enemyLanes.splice(laneIndex, 1);
                }
                this.lives--;
                this.updateUI();
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
        });
        
        // Collision detection
        this.checkCollisions();
        
        // Update particles
        this.particles.forEach((particle, index) => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life--;
            if (particle.life <= 0) {
                this.particles.splice(index, 1);
            }
        });
        
        // Spawn power-ups occasionally
        this.powerUpSpawnTimer++;
        if (this.powerUpSpawnTimer > 600) {
            this.spawnPowerUp();
            this.powerUpSpawnTimer = 0;
        }
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw stars
        this.drawStars();
        
        // Draw player
        this.drawPlayer();
        
        // Draw bullets
        this.bullets.forEach(bullet => {
            this.ctx.fillStyle = '#00ff88';
            this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            
            // Bullet glow
            this.ctx.shadowColor = '#00ff88';
            this.ctx.shadowBlur = 10;
            this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            this.ctx.shadowBlur = 0;
        });
        
        // Draw enemies
        this.enemies.forEach(enemy => {
            this.drawEnemy(enemy);
        });
        
        // Draw particles
        this.particles.forEach(particle => {
            this.ctx.fillStyle = `rgba(255, ${100 + particle.life}, 0, ${particle.life / 20})`;
            this.ctx.fillRect(particle.x, particle.y, 3, 3);
        });
        
        // Draw power-ups
        this.powerUps.forEach(powerUp => {
            this.ctx.fillStyle = '#ffaa00';
            this.ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
        });
    }
    
    drawStars() {
        for (let i = 0; i < 50; i++) {
            const x = (i * 37) % this.canvas.width;
            const y = (i * 43 + Date.now() * 0.01) % this.canvas.height;
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.sin(i) * 0.2})`;
            this.ctx.fillRect(x, y, 1, 1);
        }
    }
    
    drawPlayer() {
        const gradient = this.ctx.createLinearGradient(
            this.player.x, this.player.y,
            this.player.x, this.player.y + this.player.height
        );
        gradient.addColorStop(0, '#00ff88');
        gradient.addColorStop(1, '#0066ff');
        
        this.ctx.fillStyle = gradient;
        
        // Draw player ship
        this.ctx.beginPath();
        this.ctx.moveTo(this.player.x + this.player.width / 2, this.player.y);
        this.ctx.lineTo(this.player.x, this.player.y + this.player.height);
        this.ctx.lineTo(this.player.x + this.player.width / 4, this.player.y + this.player.height * 0.8);
        this.ctx.lineTo(this.player.x + this.player.width * 0.75, this.player.y + this.player.height * 0.8);
        this.ctx.lineTo(this.player.x + this.player.width, this.player.y + this.player.height);
        this.ctx.closePath();
        this.ctx.fill();
        
        // Engine glow
        this.ctx.fillStyle = '#ff4757';
        this.ctx.fillRect(this.player.x + this.player.width / 2 - 5, this.player.y + this.player.height, 10, 8);
    }
    
    drawEnemy(enemy) {
        this.ctx.fillStyle = '#ff4757';
        this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        
        // Enemy glow
        this.ctx.shadowColor = '#ff4757';
        this.ctx.shadowBlur = 5;
        this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        this.ctx.shadowBlur = 0;
    }
    
    shootBullet() {
        this.bullets.push({
            x: this.player.x + this.player.width / 2 - 2,
            y: this.player.y,
            width: 4,
            height: 10,
            speed: 8
        });
    }
    
    spawnEnemy() {
        // Create lanes to prevent overlap
        const laneWidth = 80; // Width of each lane
        const totalLanes = Math.floor(this.canvas.width / laneWidth);
        const availableLanes = [];
        
        // Find available lanes
        for (let i = 0; i < totalLanes; i++) {
            if (!this.enemyLanes.includes(i)) {
                availableLanes.push(i);
            }
        }
        
        // If no lanes available, clear some old ones
        if (availableLanes.length === 0) {
            this.enemyLanes = [];
            for (let i = 0; i < totalLanes; i++) {
                availableLanes.push(i);
            }
        }
        
        // Select random available lane
        const selectedLane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
        const enemyX = selectedLane * laneWidth + (laneWidth - 30) / 2; // Center in lane
        
        this.enemies.push({
            x: Math.max(0, Math.min(enemyX, this.canvas.width - 30)),
            y: -30,
            width: 30,
            height: 30,
            speed: 0.5 + Math.random() * 0.5, // Reduced from 2 + Math.random() * 2
            lane: selectedLane
        });
        
        // Mark lane as occupied
        this.enemyLanes.push(selectedLane);
    }
    
    spawnPowerUp() {
        this.powerUps.push({
            x: Math.random() * (this.canvas.width - 20),
            y: -20,
            width: 20,
            height: 20,
            speed: .5
        });
    }
    
    checkCollisions() {
        // Bullet-enemy collisions
        this.bullets.forEach((bullet, bulletIndex) => {
            this.enemies.forEach((enemy, enemyIndex) => {
                if (this.isColliding(bullet, enemy)) {
                    // Create explosion particles
                    for (let i = 0; i < 10; i++) {
                        this.particles.push({
                            x: enemy.x + enemy.width / 2,
                            y: enemy.y + enemy.height / 2,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.5) * 10,
                            life: 20
                        });
                    }
                    
                    this.bullets.splice(bulletIndex, 1);
                    // Remove lane occupation when enemy is destroyed
                    const laneIndex = this.enemyLanes.indexOf(enemy.lane);
                    if (laneIndex > -1) {
                        this.enemyLanes.splice(laneIndex, 1);
                    }
                    this.enemies.splice(enemyIndex, 1);
                    this.score += 10;
                    this.updateUI();
                }
            });
        });
        
        // Player-enemy collisions
        this.enemies.forEach((enemy, index) => {
            if (this.isColliding(this.player, enemy)) {
                // Remove lane occupation when enemy collides with player
                const laneIndex = this.enemyLanes.indexOf(enemy.lane);
                if (laneIndex > -1) {
                    this.enemyLanes.splice(laneIndex, 1);
                }
                this.enemies.splice(index, 1);
                this.lives--;
                this.updateUI();
                
                // Create damage particles
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: this.player.x + this.player.width / 2,
                        y: this.player.y + this.player.height / 2,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30
                    });
                }
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
        });
    }
    
    isColliding(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }
    
    updateUI() {
        document.getElementById('score').textContent = `Score: ${this.score}`;
        document.getElementById('lives').textContent = `Lives: ${this.lives}`;
    }
    
    gameOver() {
        this.gameRunning = false;
        alert(`Game Over! Final Score: ${this.score}`);
        this.closeGame();
    }
}

// Initialize game when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new SpaceShooterGame();
});
</script>